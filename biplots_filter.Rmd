---
title: "Exploratory analysis of RNA-seq dataset"
author: "gg"
date: "`r Sys.Date()`"
fig_caption: true
fig.path: 'figure/'
output: pdf_document
---
To run this file:
Rscript -e "rmarkdown::render('biplots_filter.Rmd')"

Setup

```{r setup, message=FALSE}
library(compositions)
library(zCompositions)
library(ALDEx2)
# you can get this from:
# https://github.com/DavidRLovell/propr
source("~/git/proprBayes/R/propr-functions.R")

library(igraph)
library(car)

############### incorporating phi into ALDEx
# calculate phi on Dirichlet log-ratio distributions
# returns dataframe of the lower-triangle of symmetrical phi metric
# requires David Lovell's propr.phisym function
#
# THIS IS NOW IN THE proprBayes source
#
############ end functions


# samples
h2 <- c("002B", "006B", "004B", "020B")
h1 <- c("30S", "4S", "010B", "001B", "009B")

bv1 <- c("010A", "006A", "009A", "012A")
bv2 <- c("27S", "016B", "008A", "012B", "014B", "013A", "017B", "018B")


```
This will generate biplots with various things painted on top for use as figures, and will serve as a supplement for how the data was processed.

Filter the refseq to a mean count across samples of greater than 5, and remove outlier samples. These are defined as samples that have abberrant taxonomic composition or that have an abberrant phenotype for their taxonomic composition. In essence these are one-off samples. The reasons for filtering are:

Samples 3A, 31S, 13B and 15B are near the midpoint on the right, and 19A and 8B are near the midpoint on the left. Five of these six microbiomes are atypical, and the other 19A is exclusively L. iners, but phenotypically is BV. We next exclude these six samples and re-examine the partitioning.

3A     near right midpoint     mix of L. iners and BV expression    long branch
31S    near right midpoint     expresses L. crispatus and BV        long branch
13B    near right midpoint     expresses exclusively Megasphaera    long branch
15B    near right midpoint     significant Bifidobacteria           long branch
8B     near left midpoint      mix of L. jensenii and G. vaginalis  mid branch
19A    near left midpoint      L.iners but expresses BV             long branch
1A     embedded in H2          L. iners and GV, but clinically h    wierd

This is a form biplot that represents distances between samples with variances of components mapped onto the plot.

```{r refseq_biplot, message=FALSE}
# this is the taxon table for samples
o <- read.table(
   "~/git/twntyfr/data/merged_readcounts_taxonomy_qiime_L6_16Sorder_color_sum.txt", header=T, row.names=1, check.names=F, sep="\t", comment.char="", quote=""
)

# this is the taxon table for reference sequences
tax <- read.table("data/cluster_tax_lookup.txt", header=T, row.names=1,
   check.names=F, sep="\t", comment.char="", quote=""
)

# this is the refseq set
d <- read.table("data/merged_readcounts_subsys4.txt", header=T,
   row.names=2, check.names=F, sep="\t", comment.char="", quote="")

sub4 <- d$subsys4
d$subsys4 <- NULL

refseq <- d$refseqIDfaa
d$refseqIDfaa <- NULL

len <- d$length
d$length <- NULL

# filter to a mean count of >2 per refseq.
# reduces the set from 49885 to 9002 refseqs

d.f <- d[which(apply(d,1,mean)> 56),]
d.f.CZM <- cmultRepl(t(d.f), label=0, method="CZM")
d.f.clr <- t( apply(d.f.CZM, 1, function(x){log(x) - mean(log(x))}) )
# calculate the total variance in the dataset
d.f.mvar.clr <- mvar(d.f.clr)

# do the Singular Value Decomposition
d.f.pcx <- prcomp(d.f.clr)

# Make the number of points equal to the number of features (for labels)
points <- c(rep("o", nrow(d.f)))
#######################################
# FIG2A and B
d.f.pcx$rotation[,2] <- d.f.pcx$rotation[,2] * -1
d.f.pcx$x[,2] <- d.f.pcx$x[,2] * -1


pdf("figs/f1_refseq_seed.pdf", height=6.5, width=12)
par(mfrow=c(1,2))
#color for labels and points (vector of 2)
col=c("black",rgb(0.2,0.2,0.2,0.2))
cex=c(0.8, .15)
biplot(d.f.pcx, cex=cex, col=col, var.axes=F, ylim=c(-150,200),
    xlab=paste("PC1: ", round(sum(d.f.pcx$sdev[1]^2)/d.f.mvar.clr, 3)),
    ylab=paste("PC2: ", round(sum(d.f.pcx$sdev[2]^2)/d.f.mvar.clr, 3)),
    scale=0, ylabs=points, main="refseq"
)
abline(h=0, lty=2)
abline(v=0, lty=2)

tax.subset <- tax[rownames(d.f),]

li <- grep("Lactobacillus;iners",tax.subset$common_taxonomy)
lc <- grep("Lactobacillus;crispatus",tax.subset$common_taxonomy)
lj <- c(grep("Lactobacillus;johnsonii",tax.subset$common_taxonomy), grep("Lactobacillus;gasseri",tax.subset$common_taxonomy))
lje <- grep("Lactobacillus;jensenii",tax.subset$common_taxonomy)
pb <- grep("Prevotella",tax.subset$common_taxonomy)
gv <- grep("Gardnerella",tax.subset$common_taxonomy)
me <- grep("Megasphaera",tax.subset$common_taxonomy)
sn <- c(grep("Sneathia",tax.subset$common_taxonomy), grep("Leptotrichia",tax.subset$common_taxonomy))
di <- grep("Dialister",tax.subset$common_taxonomy)
as <- grep("NA.",rownames(tax.subset))

# named colors
crisp <- rgb(.53,.81,1,0.25)
iners <- rgb(.3,.58,.8, 0.25)
ljon <- rgb(.25,.25,.55,0.2)
ljen <- rgb(0,1,1,0.5)
gvag <- rgb(1,.42,.42,0.25)
prev <- rgb(.67,.51,1,0.25)
mega <- rgb(.6,.8,.2,0.25)
snea <- rgb(1,.75,.8,0.25)
dial <- rgb(1,0,1,0.25)
lept <- rgb(0.65,.16,.16,0.25)
ass <- rgb(0,0,0,0.4)

tax.nms <- list(li, lc, lj, lje, pb, gv, me, sn, di, as)
tax.col <- list(iners, crisp, ljon, ljen, gvag, mega, snea, dial, ass)

crisp.l <- rgb(.53,.81,1,0.6)
iners.l <- rgb(.3,.58,.8, 0.8)
ljon.l <- rgb(.15,.25,.55,0.6)
ljen.l <- rgb(0,1,1,0.5)
gvag.l <- rgb(1,.42,.42,0.6)
prev.l <- rgb(.67,.51,1,0.6)
mega.l <- rgb(.6,.8,.2,0.6)
snea.l <- rgb(1,.75,.8,0.6)
dial.l <- rgb(1,0,1,0.6)
lept.l <- rgb(0.65,.16,.16,0.6)
ass.l <- rgb(0,0,0,1)

leg.col <- c(iners.l, crisp.l, ljon.l, ljen.l, gvag.l,prev.l, mega.l, lept.l, dial.l, ass.l)

points(d.f.pcx$rotation[,1][lc], d.f.pcx$rotation[,2][lc], pch=19, cex=0.15, col=crisp)
points(d.f.pcx$rotation[,1][lj], d.f.pcx$rotation[,2][lj], pch=19, cex=0.15, col=ljon)
points(d.f.pcx$rotation[,1][lje], d.f.pcx$rotation[,2][lje], pch=19, cex=0.15, col=ljen)
points(d.f.pcx$rotation[,1][gv], d.f.pcx$rotation[,2][gv], pch=19, cex=0.15, col=gvag)
points(d.f.pcx$rotation[,1][pb], d.f.pcx$rotation[,2][pb], pch=19, cex=0.15, col=prev)
points(d.f.pcx$rotation[,1][me], d.f.pcx$rotation[,2][me], pch=19, cex=0.15, col=mega)
points(d.f.pcx$rotation[,1][sn], d.f.pcx$rotation[,2][sn], pch=19, cex=0.15, col=lept)
points(d.f.pcx$rotation[,1][di], d.f.pcx$rotation[,2][di], pch=19, cex=0.15, col=dial)
points(d.f.pcx$rotation[,1][li], d.f.pcx$rotation[,2][li], pch=19, cex=0.15, col=iners)
points(d.f.pcx$rotation[,1][as], d.f.pcx$rotation[,2][as], pch=19, cex=0.15, col=ass)


legend(.025,.035, c("li", "lc", "lj", "lje", "gv", "pv", "me", "sn", "di", "as"),  fill=leg.col, cex=0.8)

########### REFSEQ
e <- read.table("data/AitchisonTransformedDataForALDExInput.txt", header=T,
   row.names=1, check.names=F, sep="\t", comment.char="", quote="")
e.f <- e[which(apply(e,1,mean)> 56),]

points.e <- c(rep("o", nrow(e.f)))

e.n0.CZM <- cmultRepl(t(e.f), label=0, method="CZM")

# turn this into a centered log-ratio transform
# samples are by row
# remember that apply by row rotates the data
# R is terrible, so we need to use t() again

e.clr <- t( apply(e.n0.CZM, 1, function(x){log(x) - mean(log(x))}) )

e.mvar.clr <- mvar(e.clr)

e.pcx <- prcomp(e.clr)

col=c("black",rgb(0,0,0,0.2))
cex=c(0.8, .4)
biplot(e.pcx, cex=cex, col=col, var.axes=F,
    xlab=paste("PC1: ", round(sum(e.pcx$sdev[1]^2)/e.mvar.clr, 3)),
    ylab=paste("PC2: ", round(sum(e.pcx$sdev[2]^2)/e.mvar.clr, 3)),
    scale=0, ylabs=points.e, main="SEED subsys4"
)
abline(h=0, lty=2)
abline(v=0, lty=2)

dev.off()


##########################
#### BV ONLY

d.min <- data.frame(d[,bv1],d[,bv2])


# filter to a mean count of >2 per refseq.
# reduces the set from 49885 to 10052 refseqs

d.min <- d.min[which(apply(d.min,1,mean)> 24),]

# we need to replace 0 values with a best estimate
# use zCompositions CZM by default
# but samples must be by row, so use t()

d.n0.CZM <- cmultRepl(t(d.min), label=0, method="CZM")

# turn this into a centered log-ratio transform
# samples are by row
# remember that apply() by row rotates the data
# R is terrible, so we need to use t() again

d.clr <- t( apply(d.n0.CZM, 1, function(x){log(x) - mean(log(x))}) )

# calculate the total variance in the dataset
d.mvar.clr <- mvar(d.clr)

# do the Singular Value Decomposition
d.pcx <- prcomp(d.clr)

# plot it
# subsets
tax.subset <- tax[rownames(d.min),]

li <- grep("Lactobacillus;iners",tax.subset$common_taxonomy)
lc <- grep("Lactobacillus;crispatus",tax.subset$common_taxonomy)
lj <- c(grep("Lactobacillus;johnsonii",tax.subset$common_taxonomy), grep("Lactobacillus;gasseri",tax.subset$common_taxonomy))
lje <- grep("Lactobacillus;jensenii",tax.subset$common_taxonomy)
pb <- grep("Prevotella",tax.subset$common_taxonomy)
gv <- grep("Gardnerella",tax.subset$common_taxonomy)
me <- grep("Megasphaera",tax.subset$common_taxonomy)
sn <- c(grep("Sneathia",tax.subset$common_taxonomy), grep("Leptotrichia",tax.subset$common_taxonomy))
di <- grep("Dialister",tax.subset$common_taxonomy)
as <- grep("NA.",rownames(tax.subset))

# named colors
crisp <- rgb(.53,.81,1,0.6)
iners <- rgb(.3,.58,.8, 0.6)
ljon <- rgb(.15,.25,.55,0.6)
ljen <- rgb(0,1,1,0.5)
bvab <- rgb(1,1,0,0.5)
gvag <- rgb(1,.42,.42,0.6)
prev <- rgb(.67,.51,1,0.6)
mega <- rgb(.6,.8,.2,0.6)
snea <- rgb(1,.75,.8,0.6)
dial <- rgb(1,0,1,0.6)
lept <- rgb(0.65,.16,.16,0.6)
ass <- rgb(0,0,0,0.6)

tax.nms <- list(li, lc, lj, lje, pb, gv, me, sn, di, as)
tax.col <- list(iners, crisp, ljon, ljen, gvag, mega, snea, dial, ass)

# Make the number of points equal to the number of features (for labels)
points <- c(rep("o", nrow(d.min)))

#color for labels and points (vector of 2)
col=c("black",rgb(0.2,0.2,0.2,0.0))
cex=c(0.8, .2)
##########################
#### BV ONLY

d.min <- data.frame(d[,bv1],d[,bv2], check.names=F)


# filter to a mean count of >2 per refseq.
# reduces the set from 49885 to 10052 refseqs

d.min <- d.min[which(apply(d.min,1,mean)> 24),]

# we need to replace 0 values with a best estimate
# use zCompositions CZM by default
# but samples must be by row, so use t()

d.n0.CZM <- cmultRepl(t(d.min), label=0, method="CZM")

# turn this into a centered log-ratio transform
# samples are by row
# remember that apply() by row rotates the data
# R is terrible, so we need to use t() again

d.clr <- t( apply(d.n0.CZM, 1, function(x){log(x) - mean(log(x))}) )

# calculate the total variance in the dataset
d.mvar.clr <- mvar(d.clr)

# do the Singular Value Decomposition
d.pcx <- prcomp(d.clr)

# plot it
# subsets
tax.subset <- tax[rownames(d.min),]

li <- grep("Lactobacillus;iners",tax.subset$common_taxonomy)
lc <- grep("Lactobacillus;crispatus",tax.subset$common_taxonomy)
lj <- c(grep("Lactobacillus;johnsonii",tax.subset$common_taxonomy), grep("Lactobacillus;gasseri",tax.subset$common_taxonomy))
lje <- grep("Lactobacillus;jensenii",tax.subset$common_taxonomy)
pb <- grep("Prevotella",tax.subset$common_taxonomy)
gv <- grep("Gardnerella",tax.subset$common_taxonomy)
me <- grep("Megasphaera",tax.subset$common_taxonomy)
sn <- c(grep("Sneathia",tax.subset$common_taxonomy), grep("Leptotrichia",tax.subset$common_taxonomy))
di <- grep("Dialister",tax.subset$common_taxonomy)
as <- grep("NA.",rownames(tax.subset))

# named colors
crisp <- rgb(.53,.81,1,0.6)
iners <- rgb(.3,.58,.8, 0.6)
ljon <- rgb(.15,.25,.55,0.6)
ljen <- rgb(0,1,1,0.5)
bvab <- rgb(1,1,0,0.5)
gvag <- rgb(1,.42,.42,0.6)
prev <- rgb(.67,.51,1,0.6)
mega <- rgb(.6,.8,.2,0.6)
snea <- rgb(1,.75,.8,0.6)
dial <- rgb(1,0,1,0.6)
lept <- rgb(0.65,.16,.16,0.6)
ass <- rgb(0,0,0,0.6)

tax.nms <- list(li, lc, lj, lje, pb, gv, me, sn, di, as)
tax.col <- list(iners, crisp, ljon, ljen, gvag, mega, snea, dial, ass)

# Make the number of points equal to the number of features (for labels)
points <- c(rep("o", nrow(d.min)))

#color for labels and points (vector of 2)
col=c("black",rgb(0.2,0.2,0.2,0.0))
cex=c(0.8, .2)
###########################

pdf("figs/bvonly_refseq_biplot.pdf", height=6, width=6)
par(mfrow=c(1,1))
biplot(d.pcx, cex=cex, col=col, var.axes=F,
    xlab=paste("PC1: ", round(sum(d.pcx$sdev[1]^2)/d.mvar.clr, 3)),
    ylab=paste("PC2: ", round(sum(d.pcx$sdev[2]^2)/d.mvar.clr, 3)),
    scale=0, ylabs=points, expand=1.5, xlim=c(-300,150), ylim=c(-250,150)
)
#text(-.025,-.03,labels="H1", cex=1.5)
#text(-.025,.025,labels="H2", cex=1.5)
#text(.025,.025,labels="BV2", cex=1.5)
#text(.025,-.025,labels="BV1", cex=1.5)
#
#
#text(-.007,-.015,labels="Li", cex=1.0,col="steelblue3")
#text(-.01,.006,labels="Ljg", cex=1.0,col="royalblue4")
#text(-.03,-.005,labels="Lc", cex=1.0,col="skyblue1")
#text(-.016,-.012,labels="Lje", cex=1.0,col="cyan")
#text(-.007,.02,labels="Me", cex=1.0,col=mega)
#text(-.001,.027,labels="Ass", cex=1.0,col=ass)
#text(.015,-.017,labels="Pr", cex=1.0,col=prev)
#text(.017,-.002,labels="Gv", cex=1.0,col=gvag)
#text(.017,.005,labels="Di", cex=1.0,col=dial)
#text(.016,.012,labels="Sn/Le", cex=1.0,col=lept)


# plot the taxonomic colors
points(d.pcx$rotation[,1][lc], d.pcx$rotation[,2][lc], pch=19, cex=0.2, col=crisp)
points(d.pcx$rotation[,1][li], d.pcx$rotation[,2][li], pch=19, cex=0.2, col=iners)
points(d.pcx$rotation[,1][lje], d.pcx$rotation[,2][lje], pch=19, cex=0.2, col=ljen)
points(d.pcx$rotation[,1][lj], d.pcx$rotation[,2][lj], pch=19, cex=0.2, col=ljon)
points(d.pcx$rotation[,1][bvab], d.pcx$rotation[,2][bvab], pch=19, cex=0.2, col=bvab)
points(d.pcx$rotation[,1][gv], d.pcx$rotation[,2][gv], pch=19, cex=0.2, col=gvag)
points(d.pcx$rotation[,1][pb], d.pcx$rotation[,2][pb], pch=19, cex=0.2, col=prev)
points(d.pcx$rotation[,1][me], d.pcx$rotation[,2][me], pch=19, cex=0.2, col=mega)
points(d.pcx$rotation[,1][sn], d.pcx$rotation[,2][sn], pch=19, cex=0.2, col=lept)
points(d.pcx$rotation[,1][di], d.pcx$rotation[,2][di], pch=19, cex=0.2, col=dial)
points(d.pcx$rotation[,1][as], d.pcx$rotation[,2][as], pch=19, cex=0.2, col=ass)

# axes
abline(h=0, lty=2)
abline(v=0, lty=2)
dev.off()
#######


##########################
#### no-outliers

d.min <- data.frame(d[,h1], c[,h2],d[,bv1],d[,bv2])


# filter to a mean count of >2 per refseq.
# reduces the set from 49885 to 10052 refseqs

d.min <- d.min[which(apply(d.min,1,mean)> 24),]

# we need to replace 0 values with a best estimate
# use zCompositions CZM by default
# but samples must be by row, so use t()

d.n0.CZM <- cmultRepl(t(d.min), label=0, method="CZM")

# turn this into a centered log-ratio transform
# samples are by row
# remember that apply() by row rotates the data
# R is terrible, so we need to use t() again

d.clr <- t( apply(d.n0.CZM, 1, function(x){log(x) - mean(log(x))}) )

# calculate the total variance in the dataset
d.mvar.clr <- mvar(d.clr)

# do the Singular Value Decomposition
d.pcx <- prcomp(d.clr)

# plot it
# subsets
tax.subset <- tax[rownames(d.min),]

li <- grep("Lactobacillus;iners",tax.subset$common_taxonomy)
lc <- grep("Lactobacillus;crispatus",tax.subset$common_taxonomy)
lj <- c(grep("Lactobacillus;johnsonii",tax.subset$common_taxonomy), grep("Lactobacillus;gasseri",tax.subset$common_taxonomy))
lje <- grep("Lactobacillus;jensenii",tax.subset$common_taxonomy)
pb <- grep("Prevotella",tax.subset$common_taxonomy)
gv <- grep("Gardnerella",tax.subset$common_taxonomy)
me <- grep("Megasphaera",tax.subset$common_taxonomy)
sn <- c(grep("Sneathia",tax.subset$common_taxonomy), grep("Leptotrichia",tax.subset$common_taxonomy))
di <- grep("Dialister",tax.subset$common_taxonomy)
as <- grep("NA.",rownames(tax.subset))

# named colors
crisp <- rgb(.53,.81,1,0.6)
iners <- rgb(.3,.58,.8, 0.6)
ljon <- rgb(.15,.25,.55,0.6)
ljen <- rgb(0,1,1,0.5)
bvab <- rgb(1,1,0,0.5)
gvag <- rgb(1,.42,.42,0.6)
prev <- rgb(.67,.51,1,0.6)
mega <- rgb(.6,.8,.2,0.6)
snea <- rgb(1,.75,.8,0.6)
dial <- rgb(1,0,1,0.6)
lept <- rgb(0.65,.16,.16,0.6)
ass <- rgb(0,0,0,0.6)

tax.nms <- list(li, lc, lj, lje, pb, gv, me, sn, di, as)
tax.col <- list(iners, crisp, ljon, ljen, gvag, mega, snea, dial, ass)

# Make the number of points equal to the number of features (for labels)
points <- c(rep("o", nrow(d.min)))

#color for labels and points (vector of 2)
col=c("black",rgb(0.2,0.2,0.2,0.0))
cex=c(0.8, .2)
###########################

pdf("figs/supp_refseq_biplot.pdf", height=6, width=6)
par(mfrow=c(1,1))
biplot(d.pcx, cex=cex, col=col, var.axes=F,
    xlab=paste("PC1: ", round(sum(d.pcx$sdev[1]^2)/d.mvar.clr, 3)),
    ylab=paste("PC2: ", round(sum(d.pcx$sdev[2]^2)/d.mvar.clr, 3)),
    scale=0, ylabs=points, expand=1.5
)
text(-.025,-.03,labels="H1", cex=1.5)
text(-.025,.025,labels="H2", cex=1.5)
text(.025,.025,labels="BV2", cex=1.5)
text(.025,-.025,labels="BV1", cex=1.5)


text(-.007,-.015,labels="Li", cex=1.0,col="steelblue3")
text(-.01,.006,labels="Ljg", cex=1.0,col="royalblue4")
text(-.03,-.005,labels="Lc", cex=1.0,col="skyblue1")
text(-.016,-.012,labels="Lje", cex=1.0,col="cyan")
text(-.007,.02,labels="Me", cex=1.0,col=mega)
text(-.001,.027,labels="Ass", cex=1.0,col=ass)
text(.015,-.017,labels="Pr", cex=1.0,col=prev)
text(.017,-.002,labels="Gv", cex=1.0,col=gvag)
text(.017,.005,labels="Di", cex=1.0,col=dial)
text(.016,.012,labels="Sn/Le", cex=1.0,col=lept)


# plot the taxonomic colors
points(d.pcx$rotation[,1][lc], d.pcx$rotation[,2][lc], pch=19, cex=0.2, col=crisp)
points(d.pcx$rotation[,1][li], d.pcx$rotation[,2][li], pch=19, cex=0.2, col=iners)
points(d.pcx$rotation[,1][lje], d.pcx$rotation[,2][lje], pch=19, cex=0.2, col=ljen)
points(d.pcx$rotation[,1][lj], d.pcx$rotation[,2][lj], pch=19, cex=0.2, col=ljon)
points(d.pcx$rotation[,1][bvab], d.pcx$rotation[,2][bvab], pch=19, cex=0.2, col=bvab)
points(d.pcx$rotation[,1][gv], d.pcx$rotation[,2][gv], pch=19, cex=0.2, col=gvag)
points(d.pcx$rotation[,1][pb], d.pcx$rotation[,2][pb], pch=19, cex=0.2, col=prev)
points(d.pcx$rotation[,1][me], d.pcx$rotation[,2][me], pch=19, cex=0.2, col=mega)
points(d.pcx$rotation[,1][sn], d.pcx$rotation[,2][sn], pch=19, cex=0.2, col=lept)
points(d.pcx$rotation[,1][di], d.pcx$rotation[,2][di], pch=19, cex=0.2, col=dial)
points(d.pcx$rotation[,1][as], d.pcx$rotation[,2][as], pch=19, cex=0.2, col=ass)

# axes
abline(h=0, lty=2)
abline(v=0, lty=2)
dev.off()
#######

```

This is a good representation of the data explaining `r round(sum(d.pcx$sdev[1]^2)/d.mvar.clr, 3)` proportion of the variance in the data on the first component, and a much smaller amount on the second and later components. This reduced dataset contains `r nrow(d.min)` genes. We can see that the samples cluster into a few fairly discrete groups. These groups contain fairly discrete sets of genes, and we can infer that the sample set distributions are driven by gene occurrence in different genomes.

To get around the correlation between gene occurrence and expression, we aggregate the data to the SEED subsystem 4 level. This is done on the same set of samples.

```{r subsys4_KO__biplot,message=FALSE,warning=FALSE}

e <- read.table("data/AitchisonTransformedDataForALDExInput.txt", header=T,
   row.names=1, check.names=F, sep="\t", comment.char="", quote="")

all.in <- data.frame(e[,h1], e[,h2], e[,bv1], e[,bv2], check.names=FALSE)

e.min <- all.in[apply(all.in,1,mean) > 0,]

e.min.n0.CZM <- cmultRepl(t(e.min), label=0, method="CZM")

# turn this into a centered log-ratio transform
# samples are by row
# remember that apply by row rotates the data
# R is terrible, so we need to use t() again

e.min.clr <- t( apply(e.min.n0.CZM, 1, function(x){log(x) - mean(log(x))}) )

e.min.mvar.clr <- mvar(e.min.clr)

points.e <- c(rep("o", nrow(e.min)))

e.min.pcx <- prcomp(e.min.clr)

#################### SUBSYS 4 BIPLOT

pdf("figs/fig3_subsys4_KO__biplot.pdf", height=6, width=11)

points.e <- c(rep("o", nrow(e.min)))

#color for labels and points (vector of 2)
col=c("black",rgb(0.2,0.2,0.2,0.2))
cex=c(0.8, .4)

par(mfrow=c(1,2))

# TODO color samples by most abundant organism
biplot(e.min.pcx,choices=c(1,2), cex=cex, col=col, var.axes=F,
    xlab=paste("PC1: ", round(sum(e.min.pcx$sdev[1]^2)/e.min.mvar.clr, 3)),
    ylab=paste("PC2: ", round(sum(e.min.pcx$sdev[2]^2)/e.min.mvar.clr, 3)),
    scale=0, ylabs=points.e, main="SEED"
)
# scale=0
text(-.085,-.085,labels="H1", cex=1.5)
text(-.085,.065,labels="H2", cex=1.5)
text(.06,.065,labels="BV2", cex=1.5)
text(.06,-.085,labels="BV1", cex=1.5)

abline(v=0, lty=2)
abline(h=0, lty=2)

###### phi with Bayesian estimation
# the problem is that a low phi can easily arise between functions
# that have the same distribution of 0 values across samples
# so we need to estimate the value of 0 (and other low-count functions)

## generate random DIR clr instances with ALDEx2 in the minimum function set
e.x <- aldex.clr(e.min)

## calculate phi divided by number of random instances
#e.min.sma.df <- aldex.phi(e.x)
#
## find the set of connections with phi less than some value
## we choose an arbitrary cutoff, but it is higher after Bayesian estimation
## obviously
#phi.cutoff <- 0.03
#
#e.min.sma.lo.phi <- subset(e.min.sma.df, phi < phi.cutoff)
#
### generate a graphical object
#g <- graph.data.frame(e.min.sma.lo.phi, directed=FALSE)
### # get the clusters from the graph object
#g.clust <- clusters(g)
#
### write them to a file
#
### # data frame containing the names and group memberships of each cluster
#g.df <- data.frame(Systematic.name=V(g)$name, cluster=g.clust$membership,
#    cluster.size=g.clust$csize[g.clust$membership])
#
#attach(g.df)
#g.order <- g.df[order(cluster),]
#detach(g.df)
#write.table(g.order, file="SEED.g.df.txt", sep="\t", quote=F, col.names=NA)
##
g.df <- read.table("SEED.g.df.txt",row.names=1, header=T, check.names=F, sep="\t", comment.char="", quote="")
big <- g.df[which(g.df$cluster.size >= 10),]
colnames(big) <- colnames(g.df)

colours <- c("indianred1", "steelblue3",  "skyblue1", "mediumorchid","royalblue4", "olivedrab3",
   "pink", "#FFED6F", "mediumorchid3", "ivory2", "tan1", "aquamarine3", "#C0C0C0",
    "mediumvioletred", "#999933", "#666699", "#CC9933", "#006666", "#3399FF",
   "#993300", "#CCCC99", "#666666", "#FFCC66", "#6699CC", "#663366", "#9999CC", "#CCCCCC",
   "#669999", "#CCCC66", "#CC6600", "#9999FF", "#0066CC", "#99CCCC", "#999999", "#FFCC00",
   "#009999", "#FF9900", "#999966", "#66CCCC", "#339966", "#CCCC33", "#EDEDED"
)


lev <- factor(big$cluster)
for(i in as.numeric(levels(lev))){
nms <- rownames(big)[big$cluster==i]
#print(rownames(big)[big$cluster==i])
#print("")
points(e.min.pcx$rotation[nms,][,1],e.min.pcx$rotation[nms,][,2], col=colours[i],
    pch=19, cex=0.4)
}

k <- read.table("data/KO_reads_aitchison_sum.txt", header=T,
    row.names=1, sep="\t", check.names=FALSE)

all.in.k <- data.frame(k[,h1], k[,h2], k[,bv1], k[,bv2], check.names=FALSE)

k.int <- all.in.k[apply(all.in.k,1,mean) > 0,]

k.min <- k.int[grep("^K", rownames(k.int)),]

k.min <- k.min[apply(k.min,1,max) > 0,]

# dim(k.min)
# 2832 21

k.min.n0.CZM <- cmultRepl(t(k.min), label=0, method="CZM")

# turn this into a centered log-ratio transform
# samples are by row
# remember that apply by row rotates the data
# R is terrible, so we need to use t() again

k.min.clr <- t( apply(k.min.n0.CZM, 1, function(x){log(x) - mean(log(x))}) )

k.min.mvar.clr <- mvar(k.min.clr)

k.min.pcx <- prcomp(k.min.clr)

#color for labels and points (vector of 2)
col=c("black",rgb(0.2,0.2,0.2,0.2))
cex=c(0.8, .4)
points.k <- c(rep("o", nrow(k.min)))

#### KO 4 BIPLOT
# TODO color samples by most abundant organism
biplot(k.min.pcx, cex=cex, col=col, var.axes=F,
    xlab=paste("PC1: ", round(sum(k.min.pcx$sdev[1]^2)/k.min.mvar.clr, 3)),
    ylab=paste("PC2: ", round(sum(k.min.pcx$sdev[2]^2)/k.min.mvar.clr, 3)),
    scale=0, ylabs=points.k, main="KEGG"
)
# scale=0
text(-.1,-.1,labels="H1", cex=1.5)
text(-.1,.08,labels="H2", cex=1.5)
text(.075,.08,labels="BV2", cex=1.5)
text(.075,-.1,labels="BV1", cex=1.5)

abline(v=0, lty=2)
abline(h=0, lty=2)

# generate random DIR clr instances with ALDEx2 in the minimum function set
k.x <- aldex.clr(k.min)
#
## calculate phi divided by number of random instances
#k.min.sma.df <- aldex.phi(k.x)
#
## find the set of connections with phi less than some value
## we choose an arbitrary cutoff, but it is higher after Bayesian estimation
## obviously
# phi.cutoff <- 0.03
#
#k.min.sma.lo.phi <- subset(k.min.sma.df, phi < phi.cutoff)
#
## generate a graphical object
#g <- graph.data.frame(k.min.sma.lo.phi, directed=FALSE)
#
## overview of all the proportional relationships
## this can take a long time!!!
## plot(g, layout=layout.fruchterman.reingold.grid(g, weight=0.05/E(g)$phi), vertex.size=1,
##   vertex.color="black", vertex.label=NA)
#
## # get the clusters from the graph object
# g.clust <- clusters(g)
#
## write them to a file
#
## # data frame containing the names and group memberships of each cluster
#KO.g.df <- data.frame(Systematic.name=V(g)$name, cluster=g.clust$membership,
#    cluster.size=g.clust$csize[g.clust$membership])
#
#attach(KO.g.df)
#k.order <- KO.g.df[order(cluster),]
#detach(KO.g.df)
#
#write.table(k.order, file="KO.g.df.txt", sep="\t", quote=F, col.names=NA)
#
KO.g.df <- read.table("KO.g.df.txt",row.names=1, header=T, check.names=F, sep="\t", comment.char="", quote="")

colours <- c("indianred1", "royalblue4", "skyblue1", "mediumorchid", "steelblue3","olivedrab3",
   "pink", "#FFED6F", "mediumorchid3", "ivory2", "tan1", "aquamarine3", "#C0C0C0",
    "mediumvioletred", "#999933", "#666699", "#CC9933", "#006666", "#3399FF",
   "#993300", "#CCCC99", "#666666", "#FFCC66", "#6699CC", "#663366", "#9999CC", "#CCCCCC",
   "#669999", "#CCCC66", "#CC6600", "#9999FF", "#0066CC", "#99CCCC", "#999999", "#FFCC00",
   "#009999", "#FF9900", "#999966", "#66CCCC", "#339966", "#CCCC33", "#EDEDED"
)

big <- KO.g.df[which(KO.g.df$cluster.size >= 10),]
colnames(big) <- colnames(KO.g.df)

lev <- factor(big$cluster)
for(i in as.numeric(levels(lev))){
nms <- rownames(big)[big$cluster==i]

points(k.min.pcx$rotation[nms,][,1],k.min.pcx$rotation[nms,][,2], col=colours[i],
    pch=19, cex=0.4)
}

dev.off()
```

The relationship between phi and effect size.

```{r phi.aldex , warning=FALSE, message=FALSE, error=FALSE}
	B <- match(rownames(e.min.pcx$x)[e.min.pcx$x[,1] > 0], rownames(e.min.pcx$x))
	H <- match(rownames(e.min.pcx$x)[e.min.pcx$x[,1] < 0], rownames(e.min.pcx$x))

	conds <- vector()
	conds[B] <- "B"
	conds[H] <- "H"

	x.e <- aldex.effect(e.x, conds, verbose=FALSE)

	plot(x.e$diff.win, x.e$diff.btw, pch=19,cex=0.4, col=rgb(0,0,0,0.2))

	abline(0,2, lty=2, col="grey")
	abline(0,-2, lty=2, col="grey")
	abline(0,1, lty=3, col="grey")
	abline(0,-1, lty=3, col="grey")

	for(i in as.numeric(levels(lev))){
	nms <- rownames(big)[big$cluster==i]
	#print(rownames(big)[big$cluster==i])
	#print("")
	points(x.e[nms,"diff.win"],x.e[nms,"diff.btw"], col=colours[i], pch=19, cex=0.5)
}

```
